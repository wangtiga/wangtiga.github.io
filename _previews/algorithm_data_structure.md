---
layout: post
title:  "排序算法总结"
date:   2019-09-26 12:00:00 +0800
tags: program
---

* category
{:toc}




## 算法分析

### 执行效率

- 1.最好 最坏 平均情况
- 2.时间复杂度 系数 常数 低阶
- 3.比较次数和交换次数

- 计算时间复杂度的方法
  * 有序度 逆序度


- 复杂度量级
  1. 常量阶 O(1)
  2. 对数阶 O(log(n))
  3. 线性阶 O(n)
  4. 线性对数阶 O(n * log(n))
  5. 平方阶 O(n^2) 立方阶 O(n^3) K次方阶 O(n^k)
  6. 指数阶 O(2^n)
  7. 阶乘阶 O(n!)



### 内存消耗

- 原地排序，空间复杂度为 O(1)
- 内部排序，待排数据都在内存


### 稳定性

- 输入序与输出序相同

> 要求订单按金额从小到大排序，金额相同，则按下单时间从早到晚排序。
> 如果输入序是按下单时间排序，那么使用稳定的排序算法，执行一次按订单金额的排序过程，就能满足上面的要求。

TODO 计算 最好 最坏 平均 情况


## 排序算法 [^VisualSort] [^GeekbangSort] 

 type       |  时间复杂度 AVG  | 比较 | 稳定 | 一句话描述 |
----------- | ---------------- | ---- | ---- | ---------- |
 Insertion  |   O(n^2)         |  Y   |  Y   | 扑克牌抓牌时排序 |
 Shell      |   O(n^1.25)      |  Y   |  N   | 增量插入   |
 Select     |   O(n^2)         |  Y   |  N   | 每次挑最大的拿  |
 Bubble     |   O(n^2)         |  Y   |  Y   | 相邻交换   |
 Quick      |   O(n * log(n))  |  Y   |  N   | 左小右大   |
 Merge      |   O(n * log(n))  |  Y   |  Y   | 最稳算法，递归合并  |
 Heap       |   O(n * log(n))  |  Y   |  N   | 取走堆顶后，剩余数据堆化，反复执行即排序 |
 Radix      |   O(d * (n+r))   |  N   |  Y   | TODO       |


### 直接插入排序

- 最好时间复杂度 O(n)
  * 待排数据有序时，如果在 有序区间 中，从后往前查找新元素的位置，每次只要比较一次就能找到。
- 最坏时间复杂度 O(n^2)
- 平均时间复杂度 O(n^2)
- 空间复杂度 O(1)
- 稳定
  * 插入过程，如果出现相同的元素，可以让新元素都在后面。

数据分为 有序 和 无序  两部分，每次从 无序区间 中取一个数据，插入到 有序区间 中合适的位置。


### 希尔排序 （增量插入排序）

- 最好时间复杂度 O(n)
- 最坏时间复杂度 O(n^2) ～ O(n^1.5)
- 平均时间复杂度 O(n^1.25)
- 空间复杂度 O(1)
- 不稳定
  * 因为不同增量回合排序过程会把相同的值放到不同位置

按增量序列进行 直接插入排序 ，减少移动比较次数。

如何选择增量序列是关键。 最后一个增量序列一般必须是 1 ，保证所有元素参与排序。

> 範例：假設有15筆資料(0~14)，Gap分別選用5,2,1 [^YehyehSort]
> 常用增量序列：Hibbard的Gap：1、3、7、...、2^k-1
- 第一回合 Gap=5 :
  * 對位置0, 5, 10作插入排序
  * 對位置1, 6, 11作插入排序
  * 對位置2, 7, 12作插入排序
  * 對位置3, 8, 13作插入排序
  * 對位置4, 9, 14作插入排序
- 第二回合 Gap=2 :
  * 對位置0, 2, 4, 6, 8, 10, 12, 14作插入排序
  * 對位置1, 3, 5, 7, 9, 11, 13作插入排序
- 第三回合 Gap=1 :
  * 分別對位置0, 1, 2, 3, ..., 14作插入排序


### 直接选择排序

- 最好时间复杂度 O(n^2)
  * 即使是已经排序好的数据，也要先遍历 无序区间 ，才能选择最（大）小的数据来插入 有序区间 。
- 最坏时间复杂度 O(n^2)
- 时间复杂度 O(n^2)
- 空间复杂度 O(1)
- 不稳定
  * 使用数组实现时，从无序区间选择的数据与有序区间进行交换时，会破坏原始顺序。
  * 比如`5,8,5,2,9`序列中，第一次找到最小数据为`2`，与`5`交换位置后，两个`5`的相对顺序改变了。

> TODO 如果用链表实现，每次只是从无序区间拿出一个数据，不会破坏无序区间的原始顺序，那选择排序也可以是稳定排序吧？
 
数据分为 有序 和 无序  两部分，每次从 无序区间 中取一个数据，插入到 有序区间 中合适的位置。
与插入排序的区别在于，每次从 无序区间 中选择的是 最大（小） 的数据。


### 冒泡排序

> 冒泡排序和插入排序的时间复杂度都是 O(n^2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？
> 从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。

- 最好时间复杂度 O(n)
  * 如果是已经排序好的数据，第一次遍历，就没有交换元素的情况。
- 最坏时间复杂度 O(n^2)
- 平均时间复杂度 O(n^2)
- 空间复杂度 O(1)
- 稳定
  * 相临数据相等时，不交换，就能保证不破坏原始顺序。

遍历数据，只要发现相临的数据顺序不对，就交换这两个数据的位置。
每次都遍历所有元素，直到遍历过程没有元素交换的情况发生，就说明完成排序操作了。


### 快速排序

- 最好时间复杂度 O(n * log_n)
  * TODO 如何算出 log_n ?
- 最坏时间复杂度 O(n^2)
- 平均时间复杂度 O(n * log_n)
- 空间复杂度 O(log_n) ~ O(n)
  * 因为会使用递归调用，会占用栈空间。
  * 占用大小与递归调用的深度有关系。
  * 调用深度与分区次数有关，最坏情况分区次数是n次，
- 不稳定
  * 交换过程会破坏原始顺序。

从数据中选择一个基准值(privot)。
然后遍历数据，将所有小于基准值的数据放到基准值左侧，大于基准值的数据放到基准值右侧。
再对左侧和右侧的数据分别执行一次快速排序的过程。

如何选择基准值是关键。
基准值越接近平均值或中位数，效率越好。


### 归并排序

归并排序是最 `稳` 的排序算法，无论什么样的数据，时间复杂度都一样。
唯一缺点是空间复杂度较高。

- 最好时间复杂度 O(n * log_n)
- 最坏时间复杂度 O(n * log_n)
- 平均时间复杂度 O(n * log_n)
- 空间复杂度 O(n)
  * 因为会使用递归调用，会占用栈空间。最大栈空间是 O(n) 。
  * 但合并数据时，会分配临时空间，这个临时空间最大也是 O(n) 。
  * 注意，虽然每次递归调用，都会分配临时空间用于合并数据，但这些空间不会同时存在，所以空间复杂度不是累积相乘的关系。
  * 即，都是子递归调用结束后，才分配新的空间。此时，子调用占用的空间也已经释放了。
- 稳定
  * 合并过程可以保证不破坏两个区间的原始顺序。


将数据分成两个区间，对每个子区间分别执行归并排序的操作。
子区间排序完毕后，合并两个区间的数据。
因为子区间已经有序，所以合并过程只要遍历一次即可完成。

合并过程时间复杂度是 O(n) ，但因为递归调用最多会执行 log_n 次，总的时间复杂度是 O(n * log_n) ;
但需要申请一个临时空间，用于保存合并结果，所以空间复杂度也是 O(n) 。



### 堆排序[^GeekbangHeapSort]

- 如何理解堆

堆，必须是完全二叉树，所以适合用数组存储。每个节点的值都大于（或小于等于）子树中每个节点的值。

完全二叉树，是除最后中一层外，其他各层节点个数都是满的。最后一层，节点都靠左排列。


- 如何实现堆

数组比链表节省存储空间。因为数组不需要单独存储左右子节点，只需要通过数组下标的计算就能找到左右子节点储。

```txt
array
 index:|0 | 1 | 2 | 3 | 4 | 5 |
-------|--|---|---|---|---|---|
  data:|a | b | c | d | e | f |

tree
                 a(0)
               /      \
              /        \
             /          \
            /            \
           b(1)           c(2)
         /    \          /    \
        /      \        /      \
       d(3)    e(4)    f(5)

index
left  = 2 * i + 1
right = 2 * i + 2

如果数组下标从1开始，则
left  = 2 * i
right = 2 * i + 1
```


#### 堆支持哪些操作

以下两种堆化过程，时间复杂度都是 $ O( log_2(n) ) $ 。
因为堆化过程都是顺着节点路径进行比较和交换，总次数不会超过树的高度。
二叉树的高度就是 $ log_2(n) $ 。

##### 1.插入
- 从下向上堆化
  * 在数组末尾插入新元素，然后顺着节点路径向上与父亲节点对比大小并交换。

##### 2.删除堆顶
- 从上往下堆化
  * 把最后一个节点与顶层节点交换，删除数组最后一个节点。
  * 然后从顶层节点开始，顺着节点路径向下与儿子节点对比大小并交换。

> 不要直接删除顶层节点。
> 因为，直接删除顶层节点，然后顺着节点路径向下与子节点对比大小并交换的过程，会出现数组空洞，不满足完全二叉树的定义。



#### 如何排序

##### 1.建堆

从下向上，从后往前

- 初始数据

```txt
array n=len(array)=9
index:| 0 | 1 |  2 | 3 | 4 | 5 |  6 |  7 |  8 |
------|---|---|----|---|---|---|----|----|----|
 data:| 7 | 5 | 19 | 8 | 4 | 1 | 20 | 13 | 16 |

tree
                   7
                /     \
              /         \
            /             \
           5               19
         /    \          /    \
        /      \        /      \
       8        4      1       20
     /   \
    13   16
```

- 从第一个非叶子节点开始堆化

非叶子节点的索引是 `n/2 - 1 = 3` 

```txt
index = len(array)/2 - 1
index = n/2 - 1
index = 9/2 - 1
index = 4 - 1 = 3
```

堆化的过程，即以当前节点为顶点的子树符合堆的性质。
这个过程可能会深入遍历到这个子树的叶子节点。
但因为我们是从下向上执行的建堆过程，-所以能保证每次堆化的时候，都不会下探到孙子节点。-

```txt
array
index:| 0 | 1 |  2 | 3 | 4 | 5 |  6 |  7 |  8 |
------|---|---|----|---|---|---|----|----|----|
 data:| 7 | 5 | 19 | 8 | 4 | 1 | 20 | 13 | 16 |
                     ↑
		     |
tree
                   7
                /     \
              /         \
            /             \
           5               19
         /    \          /    \
        /      \        /      \
 ----→ 8        4      1       20
     /   \
    13   16

                   7
                /     \
              /         \
            /             \
           5               19
         /    \          /    \
        /      \        /      \
 ---→  16       4      1       20
     /   \
    13   8
```

- 第二个非叶子节点开始堆化

```txt
array
index:| 0 | 1 |  2 |  3 | 4 | 5 |  6 |  7 | 8 |
------|---|---|----|----|---|---|----|----|---|
 data:| 7 | 5 | 19 | 16 | 4 | 1 | 20 | 13 | 8 |
                 ↑
	         |
tree

                   7
                /     \
              /         \
            /             \
           5          ---→ 19
         /    \          /    \
        /      \        /      \
       16       4      1       20
     /   \
    13   8

                   7
                /     \
              /         \
            /             \
           5          ---→ 20 
         /    \          /    \
        /      \        /      \
       16       4      1       19
     /   \
    13   8
```


- 第三个非叶子节点开始堆化

```txt
array
index:| 0 | 1 |  2 |  3 | 4 | 5 |  6 |  7 | 8 |
------|---|---|----|----|---|---|----|----|---|
 data:| 7 | 5 | 20 | 16 | 4 | 1 | 19 | 13 | 8 |
            ↑
	    |
tree

                   7
                /     \
              /         \
            /             \
      ---→ 5               20
         /    \          /    \
        /      \        /      \
       16       4      1       19
     /   \
    13   8

                   7
                /     \
              /         \
            /             \
      ---→ 16               20 
         /    \          /    \
        /      \        /      \
  ---→ 5       4      1       19
     /   \
    13   8

// 注意：即使我们是从下向上执行的建堆过程，
// 还是不能保证每次堆化的时候，都不会下探到孙子节点。
// 因为父子节点交换后，要
// 保证儿子和孙子节点也满足堆的定义。
// 所以还要对 `1` 的左子节点 `1*2+1=3` 执行堆化过程，
// 即还要比较 `3*2+1` 与 `3*2+2` 这两个儿子 

                   7
                /     \
              /         \
            /             \
      ---→ 16               20 
         /    \          /    \
        /      \        /      \
  ---→ 13       4      1       19
     /   \
--→ 5     8

```

- 第四个非叶子节点开始堆化

```txt
array
index:| 0 |  1 |  2 |  3 | 4 | 5 |  6 | 7 | 8 |
------|---|----|----|----|---|---|----|---|---|
 data:| 7 | 16 | 20 | 13 | 4 | 1 | 19 | 5 | 8 |
        ↑
        |
tree

              ---→ 7
                /     \
              /         \
            /             \
           16              20
         /    \          /    \
        /      \        /      \
       13       4      1       19
     /   \
     5   8


              ---→ 20
                /     \
              /         \
            /             \
           16         ---→ 7
         /    \          /   \
        /      \        /     \
       13       4      1      19
     /   \
     5   8

              ---→ 20
                /     \
              /         \
            /             \
           16         ---→ 19
         /    \          /   \
        /      \        /     \
       13       4      1   --→ 7
     /   \
     5   8
```

- 结束

```txt
array
index:|  0 |  1 |  2 |  3 | 4 | 5 | 6 | 7 | 8 |
------|----|----|----|----|---|---|---|---|---|
 data:| 20 | 16 | 19 | 13 | 4 | 1 | 7 | 5 | 8 |
```

代码示例如下：

```java
private static void buildHeap(int[] a, int n) {
  for (int i = n/2; i >= 1; --i) {
    heapify(a, n, i);
  }
}

private static void heapify(int[] a, int n, int i) {
  while (true) {
    int maxPos = i;
    int left = i*2;
    int right = i*2+1;
    if (left <= n && a[maxPos] < a[left]) maxPos = left;
    if (right <= n && a[maxPos] < a[right]) maxPos = right;
    if (maxPos == i) break;
    swap(a, i, maxPos);
    i = maxPos;
  }
}

```

> 也可以向堆中一个一个加入数据的过程进行堆化。
> 即，每次插入一个数据，然后对新插入的数据执行"从下往上"堆化。
> 这样的建堆过程时间复杂度约 $ O(n * log(n)) $ 
> 经过计算能简化为 $ O(n) $ ，参考《数据结构与算法之美》王争


##### 2.排序

建堆完毕后，第0个元素就是最大元素。
此时，把第 `0` 个元素与第 `n-1` 个元素交换，再对第 `0` 到第 `n-2` 个元素执行一次堆化的过程，依此类推，重复执行次就完成了排序过程。

> 堆的实际应用场景
- 1.topK
  对数据建堆后，移除K次堆顶即可
- 2.数据流的中位数（中值）[leetcode](https://leetcode-cn.com/problems/find-median-from-data-stream/comments/)
  读取流的数据时，维护一个 maxHeap 和一个 minHeap 。
  maxHeap 的数据都比 minHeap 大，而且他们两个数数量基本一致（最多差1个）。
  maxHeap 保存小于 middleNum 的数；
  minHeap 保存大于 middleNum 的数；
  如果插入新元素后，两个堆的个数不一致，就把 middleNum 插入数量较少的堆。
  然后从数量较多的堆中，取出堆顶赋值给 middleNum 。
  所有数据处理完毕后。如果两个堆的个数不一致。数量多的堆顶，就是中位数；如果两个堆的个数一致，中位数是两个堆顶的平均值。

> 中值就是中位数。
> 中位数是排序后，索引位置是中间的那个数。即，大于中值的元素个与小于中值的元素个数一样。

#### 堆排序与快速排序比较

堆排序多是随机访问，快速排序多是局部顺序访问

堆排序交换次数比快速排序多


[^VisualSort]: [visualgo.net 可视化排序](https://visualgo.net/en/sorting)
[^YehyehSort]: [yehyeh 总结的排序算法](http://notepad.yehyeh.net/Content/Algorithm/Sort/Sort.php)
[^GeekbangSort]: [数据结构与算法之美 排序](https://time.geekbang.org/column/article/41802)
[^GeekbangHeapSort]: [数据结构与算法之美 堆排序](https://time.geekbang.org/column/article/69913)


